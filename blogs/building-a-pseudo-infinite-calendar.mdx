---
title: Building a pseudo infinite calendar
slug: building-a-pseudo-infinite-calendar
pubDate: 2025-09-23
description: A dynamic way to render only the required weeks on to the screen using virtualized lists.
author: Ashish Khare
hasAudio: false
draft: false
banner: ./assets/building-a-pseudo-infinite-calendar/banner.webp
---

![banner](./assets/building-a-pseudo-infinite-calendar/banner.webp)

Let me start off with what we are going to build. The challenge is to create an infinite calendar where you can view daily recorded journals. We'll strictly focus on implementing the calendar.


Demo: [Infinite calendar](https://infinite-calendar-scroll.vercel.app/)

## Requirements

Here are some requirements for buttery-smooth ui.

1. Implement infinite past/future scroll
2. Ensure continuous scroll — not snap-to-month
3. Support partial visibility of two months in viewport
4. Implement seamless loading of new months without flicker or jumps
5. Virtualize rows (weeks) to reduce DOM nodes
6. Compute week rows on the fly
7. Optimize images with lazy loading


For this task, I wanted to experiment with virtual lists and on-demand week data generation. The image shows the intuition behind the trick I used to render (almost or pseudo) infinite months on the calendar. I broke it into two parts — let’s talk about both.

![Illustration explaining the calendar loadout](./assets/building-a-pseudo-infinite-calendar/technique.webp)

## Only Future
At first, I thought about how to generate future months. This can be done by adding subsequent weeks to the current week. (Here, the `date-fns` library helped a lot by handling edge cases for calendar days.) For example:

```md
Current Week + 1 Week = Next Week
Current Week + 2 Weeks = Second Week in the Future
...
and so on.

Broadly,
Current Week + n Weeks = nth Week in the Future
```

For a continuous calendar, we don’t need to worry about month padding. All we need to do is calculate the nth week in the future that’s requested for rendering.

In this case, I used the `react-virtuoso` feature that returns the index of the row being rendered on the screen. We can use this index directly to calculate the week needed. This way, we can render (almost) infinite months into the future.

## Past as Well
Rendering past months was more challenging. For some reason, binary search kept coming to mind — so I thought, why not start in the middle and expand in both directions?

By splitting the rows into two parts, the upper part represents past weeks and the lower part represents future weeks, with the current week in the middle (see the image). We can then reuse the previous technique to calculate weeks.

```md
Middle Row – Row Index = Offset

If Offset > 0 → Current Week – Offset Weeks = Past Week  
If Offset = 0 → Current Week  
If Offset < 0 → Current Week + |Offset| Weeks = Future Week
```

However, doing this in `react-virtuoso` was tricky, since it only counts rows from zero up to the total row count. To solve this, I chose the middle (`total_row_count / 2`) as the starting point, scrolled to it [initially](https://virtuoso.dev/initial-index/), and then computed weeks relative to it. The offset is simply `(middle - row_index)`. The sign of the offset tells us whether to add weeks (future) or subtract weeks (past).

## Conclusion

We can treat the middle as the origin, calculate offsets on both sides, and then decide based on the sign whether to move forward (future) or backward (past).

Now, how do we calculate the active month for the header? For this, I found a handy callback prop in the `react-virtuoso` component: [`rangeChanged`](https://virtuoso.dev/range-change-callback/). It provides the `startIndex` and `endIndex` of the currently rendered range (i.e., the weeks being displayed).

I simply take the mean of these two values and use it to calculate the offset week, which in turn determines the active month and year.

And voila! ✨

